{"meta":{"title":"Fingle","subtitle":"fingle","description":"你脖子扬起来，看云，云就散了；看雨，雨就收了；看我，我就酥了！","author":"fingle","url":"https://chiseller.github.io"},"pages":[],"posts":[{"title":"Mac搭建PHP开发环境","slug":"Mac搭建PHP开发环境","date":"2017-05-03T01:05:57.000Z","updated":"2018-01-02T05:33:49.718Z","comments":true,"path":"2017/05/03/Mac搭建PHP开发环境/","link":"","permalink":"https://chiseller.github.io/2017/05/03/Mac搭建PHP开发环境/","excerpt":"Mac搭建PHP开发环境(mamp+phpstorm+xdebug)","text":"Mac搭建PHP开发环境(mamp+phpstorm+xdebug) OS版本 一.首先下载搭建环境所需要的软件1.phpstorm 密码: jebr2.mamp pro密码: mhia3.chrome4.JetBrains IDE Support(chrome插件) 二.安装成功之后配置mamp新建一个server目录默认会生成以下两个文件 mamp是自带xdebug的,因此我们不需要brew来安装xdebug,直接启用启动serve之后默认会跳转mamp的信息界面 点击菜单栏的phpinfo,边可以看到php的相关配置 然后再 三.配置phpstorm删掉index.php的所有代码输入一段测试代码 配置项目的运行环境选择php位置 然后apply ok修改端口 配置DBCpProxy 四.chromeJetBrains IDE Support Chrome插件并启用五.打断点调试","categories":[{"name":"PHP","slug":"PHP","permalink":"https://chiseller.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://chiseller.github.io/tags/PHP/"},{"name":"MAC","slug":"MAC","permalink":"https://chiseller.github.io/tags/MAC/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://chiseller.github.io/categories/PHP/"}]},{"title":"Mac终端制作带密码的压缩包","slug":"Mac终端制作带密码的压缩包","date":"2016-05-07T03:35:57.000Z","updated":"2018-01-02T05:31:49.651Z","comments":true,"path":"2016/05/07/Mac终端制作带密码的压缩包/","link":"","permalink":"https://chiseller.github.io/2016/05/07/Mac终端制作带密码的压缩包/","excerpt":"","text":"刚在网上闲逛看到的，记录一下，以备不时之需 ^_^！ 1. 只压缩单个文件zip -e yourZipFileName.zip yourSourceFile回车 ，分别输入密码（回车）和确认密码（回车）就OK了。 2. 压缩文件夹zip -e -r yourZipFileName.zip yourSourceFileDir 3. 一行行命令搞定zip -r -P yourPassword yourZipFileName.zip yourSourceFileDir 注意：万一输错密码就悲剧了！！！！！！！","categories":[{"name":"Mac","slug":"Mac","permalink":"https://chiseller.github.io/categories/Mac/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://chiseller.github.io/tags/bash/"},{"name":"Mac","slug":"Mac","permalink":"https://chiseller.github.io/tags/Mac/"}],"keywords":[{"name":"Mac","slug":"Mac","permalink":"https://chiseller.github.io/categories/Mac/"}]},{"title":"iOS视频开发（一）","slug":"iOS视频开发（一）","date":"2016-05-03T01:05:57.000Z","updated":"2018-01-02T04:32:27.709Z","comments":true,"path":"2016/05/03/iOS视频开发（一）/","link":"","permalink":"https://chiseller.github.io/2016/05/03/iOS视频开发（一）/","excerpt":"","text":"一、UIImagePickerControllerUIImagePickerController是UIKit框架里面的一个class，通过这个系统提供的class我们可以简单的是实现拍照、录制视频和音频。 三个步骤： 当前控制器present一个UIImagePickerController类 在当前界面就可以拍照、录制视频和音频 实现UIImagePickerController的delegate，在delegate可以获取录制的视频和音频，来进行相应的操作. 定制化UIImagePickerController // 查看摄像头是否可用 if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera] == NO) { return; } UIImagePickerController *imagePick = [[UIImagePickerController alloc]init]; imagePick.sourceType = UIImagePickerControllerSourceTypeCamera; // 我们还可以设置照片和视频拍摄的质量、是否可以开启闪光灯、是否开启手电筒 // 还可以单独设置只支持视频模式 // imagePick.mediaTypes = [[NSArray alloc] initWithObjects: (NSString *) kUTTypeMovie, nil]; imagePick.mediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera]; // UINavigationControllerDelegate,UIImagePickerControllerDelegate; imagePick.delegate = self; //拍照或者录制结束后是否可以编辑 imagePick.allowsEditing = NO; [self presentViewController:imagePick animated:YES completion:nil]; 界面的自定义cameraOverlayView属性可以自定义UIImagePickerController界面顶部的控件，但是只在UIImagePickerController的mediaTypes为UIImagePickerControllerSourceTypeCamera时可用。 实现UIImagePickerController的delegate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info{ NSString *mediaType = [info objectForKey:UIImagePickerControllerMediaType]; UIImage *originalImage, *editedImage, *imageToSave; // 处理图片 if ([mediaType isEqualToString:(NSString *)kUTTypeImage]) { editedImage = info[UIImagePickerControllerOriginalImage]; originalImage = info[UIImagePickerControllerEditedImage]; if (editedImage) { imageToSave = editedImage; }else{ imageToSave = originalImage; } UIImageWriteToSavedPhotosAlbum(imageToSave, nil, nil, nil); } //处理视频 if ([mediaType isEqualToString:(NSString *)kUTTypeMovie]) { NSString *url = [info[UIImagePickerControllerMediaURL] path]; if (UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(url)) { UISaveVideoAtPathToSavedPhotosAlbum(url, nil, nil, nil); } } [picker dismissViewControllerAnimated:YES completion:nil]; } 二、AVCaptureSession &amp; AVCaptureMovieFileOutput 要获取摄像机捕捉到的视频或者麦克风捕捉到的音频，我们需要对象表示inputs和outputs，并使用AVCaptureSession的实例来协调它们之间的数据流。 AVCaptureDevice 对象，表示声音或者视频采集设备，对应摄像头和麦克风。 AVCaptureInput的子类，配置输入端口。 AVCaptureOutput的子类， 输出采集到的视频或者图像。 AVCaptureSession来协调从输入到输出的数据流。 步骤一： 创建AVCaptureDevice 对象因为我们需要录制视频和音频所以我们需要视频的AVCaptureDevice和音频的AVCaptureDevice。 //我们同时获取了前摄像头和后摄像头因为等会我们要手动切换 //获取音频device -(AVCaptureDevice *)audioDevice{ if (!_audioDevice) { _audioDevice = [AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio].firstObject; } return _audioDevice; } //后置摄像头 -(AVCaptureDevice *)backVideoDevice{ if (!_backVideoDevice) { _backVideoDevice = [self getDeviceBy:AVCaptureDevicePositionBack]; if ([self.currentVideoDevice isTorchAvailable] &amp;&amp; [_backVideoDevice isTorchModeSupported:AVCaptureTorchModeOn]) { //可以设置是否开启闪光灯，是否开始HDR、视频防抖、白平衡什么的 //设置device之前需要先 lockForConfiguration if ([_backVideoDevice lockForConfiguration:NULL]==YES) { self.currentVideoDevice.torchMode = AVCaptureTorchModeOn; [self.currentVideoDevice unlockForConfiguration]; } } } } return _backVideoDevice; } //前置摄像头 -(AVCaptureDevice *)frontVideoDevice{ if (!_frontVideoDevice) { _frontVideoDevice = [self getDeviceBy:AVCaptureDevicePositionFront]; } return _frontVideoDevice; } 步骤二、配置inputs每个AVCaptureDevice对应一个input。 //audio input - (AVCaptureDeviceInput *)audioInput{ if (!_audioInput) { NSError *error = nil; _audioInput = [AVCaptureDeviceInput deviceInputWithDevice:self.audioDevice error:&amp;error]; } return _audioInput; } - (AVCaptureDeviceInput *)videoInput{ if (!_videoInput) { NSError *error = nil; _videoInput = [AVCaptureDeviceInput deviceInputWithDevice:self.currentVideoDevice error:&amp;error]; } return _videoInput; } 步骤三: 写入文件Output有四种： AVCaptureMovieFileOutput 写入文件AVCaptureVideoDataOutput 加工视频输出AVCaptureAudioDataOutput 加工音频输出AVCaptureStillImageOutput 捕捉输出的图像 写入文件只需要AVCaptureMovieFileOutput就可以了。 // output - (AVCaptureMovieFileOutput *)movieFileOutput{ if (!_movieFileOutput) { _movieFileOutput = [[AVCaptureMovieFileOutput alloc]init]; //CMTime drution = CMTimeMake(1, 60); //设置视频录制时间限制 kCMTimeInvalid(无限制) _movieFileOutput.maxRecordedDuration = kCMTimeInvalid; // 文件大小限制 //_movieFileOutput.maxRecordedFileSize = 1024 * 1024; AVCaptureConnection *videoConnection = [_movieFileOutput connectionWithMediaType:AVMediaTypeVideo]; // 是否支持科学防抖 if ([videoConnection isVideoStabilizationSupported]) { videoConnection.preferredVideoStabilizationMode = AVCaptureVideoStabilizationModeAuto; } videoConnection.videoOrientation = self.previewLayer.connection.videoOrientation; } return _movieFileOutput; } 步骤四： 获取AVCaptureSession- (AVCaptureSession *)session{ if (!_session) { _session = [[AVCaptureSession alloc]init]; // 设置视频质量 if ([_session canSetSessionPreset:AVCaptureSessionPresetLow]) { [_session setSessionPreset:AVCaptureSessionPresetLow]; } //增加videoinput if ([_session canAddInput:self.videoInput]) { [_session addInput:self.videoInput]; } //增加videoinput if ([_session canAddInput:self.audioInput]) { [_session addInput:self.audioInput]; } //增加fileOutput if ([_session canAddOutput:self.movieFileOutput]) { [_session addOutput:self.movieFileOutput]; } } return _session; } 这个地方需要注意下，每次我们更改AVCaptureSession的属性的时候我们都需要： [session beginConfiguration]; // Remove an existing capture device. // Add a new capture device. // Reset the preset. [session commitConfiguration]; 现在就可以录制视频并写入文件了为了实时查看我们录制的内容，我们加一个预览层。 -(AVCaptureVideoPreviewLayer *)previewLayer{ if (!_previewLayer) { _previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session]; _previewLayer.frame = [UIScreen mainScreen].bounds; _previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; _previewLayer.connection.videoOrientation = AVCaptureVideoOrientationPortrait; } return _previewLayer; } 在控制器里面调用session的startRuning方法，这个时候只是采集到了视频显示在了预览层上面，并未开始录制。 - (void)viewDidLoad { [super viewDidLoad]; self.recodingView.delegate = self; [self.view.layer insertSublayer:self.previewLayer atIndex:0]; [self.session startRunning]; } 点击录制视频,recodingView是我自定义的控件。 -(void)writePath{ if ([self.movieFileOutput isRecording] ) { [self.movieFileOutput stopRecording]; return; } NSDateFormatter * dateFormatter = [[NSDateFormatter alloc] init ]; [dateFormatter setDateFormat:@&quot;yyyyMMddHHmmss&quot;]; NSString * fileName = [[dateFormatter stringFromDate:[NSDate date]] stringByAppendingString:@&quot;.mov&quot;]; NSString * filePath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:fileName]; NSURL *filePathUrl = [NSURL fileURLWithPath:filePath]; //写文件到指定的路径，并设置代理 [self.movieFileOutput startRecordingToOutputFileURL:filePathUrl recordingDelegate:self]; } 设置代理,在视频录制的过程中会发生许多情况，比如说突然来电话，摄像头被其他程序占用，系统会发送相应的通知给我们。 - (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL fromConnections:(NSArray *)connections error:(NSError *)error{ BOOL recordSuccessfully = YES; if ([error code] != noErr) { id value = [[error userInfo] objectForKey:AVErrorRecordingSuccessfullyFinishedKey]; if (value) { recordSuccessfully = [value boolValue]; } } // 有`error`的话 有可能也是录制成功了 /* AVErrorMaximumDurationReached 时间限制 AVErrorMaximumFileSizeReached 文件大小限制 AVErrorDiskFull 磁盘已满 AVErrorDeviceWasDisconnected device连接失败 AVErrorSessionWasInterrupted 被切断（比如说来电话了） */ }","categories":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}]},{"title":"在centos上搭建git服务器","slug":"在centos上搭建git服务器","date":"2016-05-02T06:35:57.000Z","updated":"2018-01-02T05:52:41.091Z","comments":true,"path":"2016/05/02/在centos上搭建git服务器/","link":"","permalink":"https://chiseller.github.io/2016/05/02/在centos上搭建git服务器/","excerpt":"刚开始搭建blog的时候打算用ftp的,可是期间遇到了各种问题,最后选择了git,其实现在想想遇到的大部分问题应该全是权限的问题,毕竟对linux的认识只能说算是刚刚起步,等有空的时候再去好好研究吧.","text":"刚开始搭建blog的时候打算用ftp的,可是期间遇到了各种问题,最后选择了git,其实现在想想遇到的大部分问题应该全是权限的问题,毕竟对linux的认识只能说算是刚刚起步,等有空的时候再去好好研究吧. vps(系统centos6.2,git版本1.7) 安装git方法一.yum install -y git(最简单的方法)方法二.下载git源码编译安装,需要安装编译工具(不做介绍) 建立git用户(可选)注意:有些系统在你安装git的时候,可能已经给你自动建立了git用户,因此你可以忽略这一步. 添加git用户 //自动在home下建立git目录 useradd git //切换到/home下查看 ls -al //注意一定要注意查看git目录的拥有者(必须是git)和所属用户组(可以是git或者root), //否则在以后设置免密码clone和push的时候会出现Permission denied error的错误. //修改git目录拥有者和所属群组为git chown -R git:git git 修改git用户的操作权限vi /etc/passwd //找到git用户的那一行,修改如下:不允许git用户的ssh登录 git:x:500:500::/home/git:/usr/bin/git-shell 在服务器上建立裸版本库mkdir /home/testgit //这里 git init 是初始化空仓库的意思，而参数 --bare 是代表创建裸仓库，而参数 --bare 是代表创建裸仓库 git init --bare sample.git 注意:一定要查看testgit目录的拥有者(必须是git)和所属用户组(可以是git或者root),否则在以后设置免密码clone和push的时候会出现Permission denied error的错误. clone远程仓库cd Desktop git clone git@115.159.146.94:/home/testgit/sample.git //这时候会让你输入git的密码,但是我们并没有设置git用户的密码 配置公钥进行免密码登录 clone和pushmac下的公钥和密钥在 ~/.ssh下 cd ~/.ssh ls -a //会看到如下文件(如果没有请查看如何生成公钥和密钥) id_rsa(密钥) id_rsa.pub(公钥) known_host //生成公密钥 终端 ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/home/fdipzone/.ssh/id_rsa): 这里输入要生成的文件名 Enter passphrase (empty for no passphrase): 这里输入密码 Enter same passphrase again: 这里重复输入密码 Your identification has been saved in /home/fdipzone/.ssh/id_rsa. Your public key has been saved in /home/fdipzone/.ssh/id_rsa.pub. The key fingerprint is: f2:76:c3:6b:26:10:14:fc:43:e0:0c:4d:51:c9:a2:b0 The key&#39;s randomart image is: +--[ RSA 2048]----+ | .+=*.. | | . += + | | o oo+ | | E . . o | | ..S. | | .o . | | .o + | | ...oo | | +. | +-----------------+ //密钥生成成功 在centos cd /home/git/.ssh //建立授权文件 authorized_keys,文件不存在则自己新建一个 //将本地机器上的 id_rsa.pub(公钥)里面的复制一份粘贴到centos下/home/git/.ssh/authorized_keys authorized_keys文件看起来是这样的,上下两个免密码登录用户的公钥 ,上下分开. ###注意: .ssh 和 authorized_keys的拥有者必须是git,否则还是会有权限不足的问题 同步代码到自己的博客站点目录比如说我们的博客有一点点的优化,但是push代码之后无法立即查看效果,这个地方我们就需要自动同步就派上用场了。自动同步功能用到的是 git 的钩子功能， cd /home/testgit/sample.git cd hooks //这里我们创建post-receive文件 vi post-receive //在该文件里输入以下内容./home/www就是我blog站点的目录 #!/bin/bash git --work-tree=/home/www checkout -f //保存退出后，将该文件用户及用户组都设置成 gitchown git:git post-receive //由于该文件其实就是一个shell文件，我们还应该为其设置可执行权限 chmod +x post-receive 此时clone自己的blog站点,修改一下网站的名称,push到git服务器,刷新网站首页,是不是发现自己blog的名称变了! 最后再记录一下,配置ssh 免密码登录(so easy)复制自己主机下的公钥内容在自己的vps下 vi /root/.ssh/ authorized_keys //复制密钥内容进去,好了,现在ssh也可以免密码登录了","categories":[{"name":"linux","slug":"linux","permalink":"https://chiseller.github.io/categories/linux/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://chiseller.github.io/tags/bash/"},{"name":"git","slug":"git","permalink":"https://chiseller.github.io/tags/git/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"https://chiseller.github.io/categories/linux/"}]},{"title":"JavaScriptCore的基本用法（一）","slug":"JavaScriptCore的基本用法1","date":"2016-04-07T16:00:00.000Z","updated":"2018-01-02T05:52:54.915Z","comments":true,"path":"2016/04/08/JavaScriptCore的基本用法1/","link":"","permalink":"https://chiseller.github.io/2016/04/08/JavaScriptCore的基本用法1/","excerpt":"JavaScriptCore简介iOS 7中加入了JavaScriptCore框架。该框架让Objective-C和JavaScript代码直接的交互变得更加的简单方便。而且使得js可以脱离webview与oc交互。","text":"JavaScriptCore简介iOS 7中加入了JavaScriptCore框架。该框架让Objective-C和JavaScript代码直接的交互变得更加的简单方便。而且使得js可以脱离webview与oc交互。在项目中引入JavaScriptCore后，链到头文件中，除了大段的Copyright注释可以看到里面只要引入了5个文件，每个文件里都定义跟文件名对应的类： JSContext和JSValueJSContext//JSVirtualMachine为JavaScript的运行提供了底层资源，JSContext就为其提供着运行环境,该方法用来执行一段 //JS代码，并且如果其中有方法、变量等信息都会被存储在其中以便在需要的时候使用。 - (JSValue *)evaluateScript:(NSString *)script //JSContext的创建都是基于JSVirtualMachine,如果是使用- (id)init; //进行初始化，那么在其内部会自动创建一个新的JSVirtualMachine //对象然后调用前边的初始化方法 - (id)initWithVirtualMachine:(JSVirtualMachine *)virtualMachine; JSValue则可以说是JavaScript和Object-C之间互换的桥梁，它提供了多种方法可以方便地把JavaScript数据类型转换成Objective-C，或者是转换过去。其一一对应方式可见下表： 基本类型的转换JSContext *context = [[JSContext alloc] init]; JSValue *jsVal = [context evaluateScript:@&quot;2+7&quot;]; int iVal = [jsVal toInt32]; NSLog(@&quot;JSValue: %@, int: %d&quot;, jsVal, iVal); //输出9 还可以存一个Js变量在JSContext中，然后通过下标取出来。对于数组或者对象类型，JSValue也可以通过下表直接取值和赋值. [context evaluateScript:@&quot;var arr = [21, 7 ,&#39;leo&#39;]&quot;]; JSValue *value = context[@&quot;arr&quot;]; value[1] = @&quot;blog&quot;; value[7] = @7; NSArray *array = [value toArray]; 打印数组看一下 Printing description of array: &lt;__NSArrayM 0x7fabc144ea40&gt;( 21, blog, leo, &lt;null&gt;, &lt;null&gt;, &lt;null&gt;, &lt;null&gt;, 7 代码成功把数据从OC\u0010赋值到了Js数组上，而且jsValue遵循js数组的特性，无下标越位，自动延展数组大小 方法的转换（js调用oc的第一种方法）各种数据类型可以转换，Objective-C的Block也可以传入JSContext中当做JavaScript的方法使用。 context[@&quot;add&quot;] = ^(NSInteger a, NSInteger b){ //获取该方法的对象 JSValue *v = [JSContext currentThis]; //获取当前的参数 NSArray *args = [JSContext currentArguments]; NSLog(@&quot;当前对象：%@&quot;,v); NSLog(@&quot;当前参数：%@&quot;,args); NSLog(@&quot;和是%ld&quot;,a + b); }; [context evaluateScript:@&quot;add(1,2)&quot;]; 输出如下： 当前对象：GlobalObject 当前参数：( 1, 2) 和是3 上边的例子中对于”this”输出的内容是GlobalObject，这也是JSContext对象方法- (JSValue *)globalObject;所返回的内容。因为我们知道在JavaScript里，所有全局变量和方法其实都是一个全局变量的属性，在浏览器中是window，在JavaScriptCore是什么就不得而知了。 Block可以传入JSContext作方法，但是JSValue没有toBlock方法来把JavaScript方法变成Block在Objetive-C中使用。毕竟Block的参数个数和类型已经返回类型都是固定的。虽然不能把方法提取出来，但是JSValue提供了- (JSValue )callWithArguments:(NSArray )arguments;方法可以反过来将参数传进去来调用方法。 JSContext *context = [[JSContext alloc]init]; NSString *js = @&quot;function add(a,b){return a+ b;}&quot;; [context evaluateScript:js]; JSValue *value = [context[@&quot;add&quot;] callWithArguments:@[@3,@4]]; NSLog(@&quot;%@&quot;,value); 输出如下： 7 JSValue还提供 - (JSValue *)invokeMethod:(NSString *)method withArguments:(NSArray *)arguments; 让我们可以直接简单地调用对象上的方法。只是如果定义的方法是全局函数，那么很显然应该在JSContext的globalObject对象上调用该方法；如果是某JavaScript对象上的方法，就应该用相应的JSValue对象调用。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chiseller.github.io/tags/JavaScript/"},{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}]},{"title":"JavaScriptCore的基本用法（二）","slug":"JavaScriptCore的基本用法2","date":"2016-04-07T16:00:00.000Z","updated":"2018-01-02T05:54:27.045Z","comments":true,"path":"2016/04/08/JavaScriptCore的基本用法2/","link":"","permalink":"https://chiseller.github.io/2016/04/08/JavaScriptCore的基本用法2/","excerpt":"这是JavaScriptCore的第二篇","text":"这是JavaScriptCore的第二篇 代理设置（JS调用OC的第二种方法）h文件 //首先写一个协议 遵守JSExport协议 @protocol JSExportTest &lt;JSExport&gt; //宏转换下，将JS函数名称指定为Add； JSExportAs(add, - (NSInteger)add:(NSInteger)a b:(NSInteger)b); @property (nonatomic, assign) NSInteger sum; @end //建一个对象实现这个协议 @interface JSTest : NSObject&lt;JSExportTest&gt; @end m文件 @implementation JSTest @synthesize sum = _sum; //实现协议方法 - (NSInteger)add:(NSInteger)a b:(NSInteger)b{ return a + b; } -(void)setSum:(NSInteger)sum{ NSLog(@&quot;%ld&quot;,(long)sum); _sum = sum; } @end 在viewcontroller里面 JSContext *context = [[JSContext alloc] init]; //设置异常处理 self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) { [JSContext currentContext].exception = exception; NSLog(@&quot;exception:%@&quot;,exception); }; //将obj添加到context中 scontext[@&quot;obj&quot;] = [][JSTest alloc]init]; //JS里面调用obj方法，并将结果赋值给obj的sum属性 [context evaluateScript:@&quot;obj.sum = obj.add(2,3)&quot;]; 在JS中进行调用这个对象的方法，并将结果赋值sum。唯一要注意的是OC的函数命名和JS函数命名规则问题。协议中定义的是add: b:，但是JS里面方法名字是add(a,b)。可以通过JSExportAs这个宏转换成JS的函数名字。 异常处理Objective-C的异常会在运行时被Xcode捕获，而在JSContext中执行的JavaScript如果出现异常，只会被JSContext捕获并存储在exception属性上，而不会向外抛出。时时刻刻检查JSContext对象的exception是否不为nil显然是不合适，更合理的方式是给JSContext对象设置exceptionHandler，它接受的是^(JSContext *context, JSValue *exceptionValue)形式的Block。其默认值就是将传入的exceptionValue赋给传入的context的exception属性： JSContext *context = [[JSContext alloc] init]; context.exceptionHandler = ^(JSContext *con, JSValue *exception) { NSLog(@&quot;%@&quot;, exception); con.exception = exception; }; [context evaluateScript:@&quot;fengzhen = 66&quot;]; //输出: // ReferenceError: Can&#39;t find variable: fengzhen 无论是把Block传给JSContext对象让其变成avaScript方法，还是把它赋给exceptionHandler属性，在Block内都不要直接使用其外部定义的JSContext对象或者JSValue，应该将其当做参数传入到Block中，或者通过JSContext的类方法+ (JSContext *)currentContext;来获得。否则会造成循环引用使得内存无法被正确释放。 内存管理OC使用的是ARC，JS使用的是垃圾回收机制，js的引用全都是强引用，垃圾回收机制会帮他们打破这种强引用，所以JS不存在循环引用的问题。一般情况下，OC和JS对象之间内存管理都无需我们去关心。不过还是有几个注意点需要我们去留意下。 不要在block里面直接使用context，或者使用外部的JSValue对象。JSContext *context = [[JSContext alloc] init]; //设置异常处理 self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) { //直接这么使用是错误的 //context.exception = exception; [JSContext currentContext].exception = exception; NSLog(@&quot;exception:%@&quot;,exception); }; OC对象不要用属性直接保存JSValue对象，因为这样太容易造成循环引用。下面的例子： #import &lt;Foundation/Foundation.h&gt; #import &lt;JavaScriptCore/JavaScriptCore.h&gt; //首先写一个协议 遵守JSExport协议 @protocol JSExportTest &lt;JSExport&gt; //宏转换下，将JS函数名称指定为Add； JSExportAs(add, - (NSInteger)add:(NSInteger)a b:(NSInteger)b); @property (nonatomic, strong) JSValue *value; @end //建一个对象实现这个协议 @interface JSTest : NSObject&lt;JSExportTest&gt; @end #import &quot;JSTest.h&quot; @implementation JSTest @synthesize value = _value; //实现协议方法 -(void)setValue:(JSValue *)value{ _value = value; } @end viewController里面 JSContext *context = [[JSContext alloc]init]; context.exceptionHandler = ^(JSContext *j, JSValue *v){ NSLog(@&quot;%@&quot;,j.exception); }; [context evaluateScript:@&quot;function callback(){return &#39;hello world&#39;};function setObj(obj){this.obj = obj;obj.value = callback}&quot;]; [context[@&quot;setObj&quot;] callWithArguments:@[self.testObj]]; 调用JS方法，进行赋值，JS对象保留了传进来的obj，最后，JS将自己的回调callback赋值给了obj，方便obj下次回调给JS；由于JS那边保存了obj，而且obj这边也保留了JS的回调。这样就形成了循环引用。为了打破这种强引用，apple有一个JSManagedValue 的类，官方的原话： The JSManagedValue&#39;s JavaScript value is reachable from JavaScript The owner of the managed reference is reachable in Objective-C. Manually adding or removing the managed reference in the JSVirtualMachine determines reachability. JSManagedValue 帮助我们保存JSValue，里面保存的JS对象必须在JS中存在，同时 JSManagedValue 的owner在OC中也存在.因此我们把代理的m文件修改如下： -(void)setValue:(JSValue *)value{ // 由于是回掉的关系 obj保存了JS的回掉， js也保存了obj，这样就形成了循环引用 // JSManageValue帮助我们保存了JSValue，哪里保存的js对象在js中存在。 JSMangerValue的owner在OC中也存在。 JSManagedValue *mavalue = [JSManagedValue managedValueWithValue:value]; //建立弱引用关系 [[[JSContext currentContext] virtualMachine] addManagedReference:mavalue withOwner:self]; _value = value; } 不要在不同的 JSVirtualMachine 之间进行传递JS对象。一个JSVirtualMachine可以运行多个context，由于都是在同一个堆内存和同一个垃圾回收下，所以相互之间传值是没问题的。但是如果在不同的 JSVirtualMachine传值，垃圾回收就不知道他们之间的关系了，可能会引起异常。 JavaScriptCore线程是安全的。每个context运行的时候通过lock关联的JSVirtualMachine。如果要进行并发操作，可以创建多个JSVirtualMachine实例进行操作。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chiseller.github.io/tags/JavaScript/"},{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}]}]}