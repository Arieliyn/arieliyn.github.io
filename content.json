{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2017-12-30T14:50:10.577Z","updated":"2017-12-30T14:50:10.577Z","comments":true,"path":"2017/12/30/hello-world/","link":"","permalink":"http://yoursite.com/2017/12/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"Python学习笔记（一）","slug":"Python学习笔记（一）","date":"2017-07-19T01:44:20.000Z","updated":"2017-12-13T13:09:24.946Z","comments":true,"path":"2017/07/19/Python学习笔记（一）/","link":"","permalink":"http://yoursite.com/2017/07/19/Python学习笔记（一）/","excerpt":"","text":"除法 X / Y 2.6之前的版本会省去小数部分，3版本之后无论任何类型都会保持小数部分。 X // Y Floor除法，不管哪个版本，总是省略小数部分,也称为截断除法，结果会向下舍入 import math print(math.floor(-2.5)) //输出-3 （向下舍入） print(math.floor(2.5)) //输出2 （向下舍入） print(math.trunc(5 / -2))//输出-2 print(math.trunc(5 / 2))//输出2 如果你真的只想截断，而不管符号，可以通过math.trunc来得到一个浮点除法","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"keywords":[]},{"title":"Mac搭建PHP开发环境","slug":"Mac搭建PHP开发环境","date":"2017-05-03T01:05:57.000Z","updated":"2017-12-13T13:09:24.946Z","comments":true,"path":"2017/05/03/Mac搭建PHP开发环境/","link":"","permalink":"http://yoursite.com/2017/05/03/Mac搭建PHP开发环境/","excerpt":"Mac搭建PHP开发环境(mamp+phpstorm+xdebug)","text":"Mac搭建PHP开发环境(mamp+phpstorm+xdebug) OS版本 一.首先下载搭建环境所需要的软件1.phpstorm 密码: jebr2.mamp pro密码: mhia3.chrome4.JetBrains IDE Support(chrome插件) 二.安装成功之后配置mamp新建一个server目录默认会生成以下两个文件 mamp是自带xdebug的,因此我们不需要brew来安装xdebug,直接启用启动serve之后默认会跳转mamp的信息界面 点击菜单栏的phpinfo,边可以看到php的相关配置 然后再 三.配置phpstorm删掉index.php的所有代码输入一段测试代码 配置项目的运行环境选择php位置 然后apply ok修改端口 配置DBCpProxy 四.chromeJetBrains IDE Support Chrome插件并启用五.打断点调试","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"},{"name":"MAC","slug":"MAC","permalink":"http://yoursite.com/tags/MAC/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}]},{"title":"雨后","slug":"思考","date":"2017-05-03T01:05:57.000Z","updated":"2017-12-13T13:09:24.947Z","comments":true,"path":"2017/05/03/思考/","link":"","permalink":"http://yoursite.com/2017/05/03/思考/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}]},{"title":"视频","slug":"三个md","date":"2017-05-03T01:05:57.000Z","updated":"2017-12-30T14:50:12.933Z","comments":true,"path":"2017/05/03/三个md/","link":"","permalink":"http://yoursite.com/2017/05/03/三个md/","excerpt":"","text":"###一、UIImagePickerControllerUIImagePickerController是UIKit框架里面的一个class，通过这个系统提供的class我们可以简单的是实现拍照、录制视频和音频。 三个步骤： 当前控制器present一个UIImagePickerController类 在当前界面就可以拍照、录制视频和音频 实现UIImagePickerController的delegate，在delegate可以获取录制的视频和音频，来进行相应的操作. 定制化UIImagePickerController // 查看摄像头是否可用 if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera] == NO) { return; } UIImagePickerController *imagePick = [[UIImagePickerController alloc]init]; imagePick.sourceType = UIImagePickerControllerSourceTypeCamera; // 我们还可以设置照片和视频拍摄的质量、是否可以开启闪光灯、是否开启手电筒 // 还可以单独设置只支持视频模式 // imagePick.mediaTypes = [[NSArray alloc] initWithObjects: (NSString *) kUTTypeMovie, nil]; imagePick.mediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera]; // UINavigationControllerDelegate,UIImagePickerControllerDelegate; imagePick.delegate = self; //拍照或者录制结束后是否可以编辑 imagePick.allowsEditing = NO; [self presentViewController:imagePick animated:YES completion:nil]; 界面的自定义cameraOverlayView属性可以自定义UIImagePickerController界面顶部的控件，但是只在UIImagePickerController的mediaTypes为UIImagePickerControllerSourceTypeCamera时可用。 实现UIImagePickerController的delegate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info{ NSString *mediaType = [info objectForKey:UIImagePickerControllerMediaType]; UIImage *originalImage, *editedImage, *imageToSave; // 处理图片 if ([mediaType isEqualToString:(NSString *)kUTTypeImage]) { editedImage = info[UIImagePickerControllerOriginalImage]; originalImage = info[UIImagePickerControllerEditedImage]; if (editedImage) { imageToSave = editedImage; }else{ imageToSave = originalImage; } UIImageWriteToSavedPhotosAlbum(imageToSave, nil, nil, nil); } //处理视频 if ([mediaType isEqualToString:(NSString *)kUTTypeMovie]) { NSString *url = [info[UIImagePickerControllerMediaURL] path]; if (UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(url)) { UISaveVideoAtPathToSavedPhotosAlbum(url, nil, nil, nil); } } [picker dismissViewControllerAnimated:YES completion:nil]; } ###二、AVCaptureSession &amp; AVCaptureMovieFileOutput 要获取摄像机捕捉到的视频或者麦克风捕捉到的音频，我们需要对象表示inputs和outputs，并使用AVCaptureSession的实例来协调它们之间的数据流。 AVCaptureDevice 对象，表示声音或者视频采集设备，对应摄像头和麦克风。 AVCaptureInput的子类，配置输入端口。 AVCaptureOutput的子类， 输出采集到的视频或者图像。 AVCaptureSession来协调从输入到输出的数据流。 #####步骤一： 创建AVCaptureDevice 对象因为我们需要录制视频和音频所以我们需要视频的AVCaptureDevice和音频的AVCaptureDevice。 //我们同时获取了前摄像头和后摄像头因为等会我们要手动切换 //获取音频device -(AVCaptureDevice *)audioDevice{ if (!_audioDevice) { _audioDevice = [AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio].firstObject; } return _audioDevice; } //后置摄像头 -(AVCaptureDevice *)backVideoDevice{ if (!_backVideoDevice) { _backVideoDevice = [self getDeviceBy:AVCaptureDevicePositionBack]; if ([self.currentVideoDevice isTorchAvailable] &amp;&amp; [_backVideoDevice isTorchModeSupported:AVCaptureTorchModeOn]) { //可以设置是否开启闪光灯，是否开始HDR、视频防抖、白平衡什么的 //设置device之前需要先 lockForConfiguration if ([_backVideoDevice lockForConfiguration:NULL]==YES) { self.currentVideoDevice.torchMode = AVCaptureTorchModeOn; [self.currentVideoDevice unlockForConfiguration]; } } } } return _backVideoDevice; } //前置摄像头 -(AVCaptureDevice *)frontVideoDevice{ if (!_frontVideoDevice) { _frontVideoDevice = [self getDeviceBy:AVCaptureDevicePositionFront]; } return _frontVideoDevice; } #####步骤二、配置inputs每个AVCaptureDevice对应一个input。 //audio input - (AVCaptureDeviceInput *)audioInput{ if (!_audioInput) { NSError *error = nil; _audioInput = [AVCaptureDeviceInput deviceInputWithDevice:self.audioDevice error:&amp;error]; } return _audioInput; } - (AVCaptureDeviceInput *)videoInput{ if (!_videoInput) { NSError *error = nil; _videoInput = [AVCaptureDeviceInput deviceInputWithDevice:self.currentVideoDevice error:&amp;error]; } return _videoInput; } #####步骤三: 写入文件Output有四种： AVCaptureMovieFileOutput 写入文件AVCaptureVideoDataOutput 加工视频输出AVCaptureAudioDataOutput 加工音频输出AVCaptureStillImageOutput 捕捉输出的图像 写入文件只需要AVCaptureMovieFileOutput就可以了。 // output - (AVCaptureMovieFileOutput *)movieFileOutput{ if (!_movieFileOutput) { _movieFileOutput = [[AVCaptureMovieFileOutput alloc]init]; //CMTime drution = CMTimeMake(1, 60); //设置视频录制时间限制 kCMTimeInvalid(无限制) _movieFileOutput.maxRecordedDuration = kCMTimeInvalid; // 文件大小限制 //_movieFileOutput.maxRecordedFileSize = 1024 * 1024; AVCaptureConnection *videoConnection = [_movieFileOutput connectionWithMediaType:AVMediaTypeVideo]; // 是否支持科学防抖 if ([videoConnection isVideoStabilizationSupported]) { videoConnection.preferredVideoStabilizationMode = AVCaptureVideoStabilizationModeAuto; } videoConnection.videoOrientation = self.previewLayer.connection.videoOrientation; } return _movieFileOutput; } #####步骤四： 获取AVCaptureSession - (AVCaptureSession *)session{ if (!_session) { _session = [[AVCaptureSession alloc]init]; // 设置视频质量 if ([_session canSetSessionPreset:AVCaptureSessionPresetLow]) { [_session setSessionPreset:AVCaptureSessionPresetLow]; } //增加videoinput if ([_session canAddInput:self.videoInput]) { [_session addInput:self.videoInput]; } //增加videoinput if ([_session canAddInput:self.audioInput]) { [_session addInput:self.audioInput]; } //增加fileOutput if ([_session canAddOutput:self.movieFileOutput]) { [_session addOutput:self.movieFileOutput]; } } return _session; } 这个地方需要注意下，每次我们更改AVCaptureSession的属性的时候我们都需要： [session beginConfiguration]; // Remove an existing capture device. // Add a new capture device. // Reset the preset. [session commitConfiguration]; 现在就可以录制视频并写入文件了为了实时查看我们录制的内容，我们加一个预览层。 -(AVCaptureVideoPreviewLayer *)previewLayer{ if (!_previewLayer) { _previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session]; _previewLayer.frame = [UIScreen mainScreen].bounds; _previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; _previewLayer.connection.videoOrientation = AVCaptureVideoOrientationPortrait; } return _previewLayer; } 在控制器里面调用session的startRuning方法，这个时候只是采集到了视频显示在了预览层上面，并未开始录制。 - (void)viewDidLoad { [super viewDidLoad]; self.recodingView.delegate = self; [self.view.layer insertSublayer:self.previewLayer atIndex:0]; [self.session startRunning]; } 点击录制视频,recodingView是我自定义的控件。 -(void)writePath{ if ([self.movieFileOutput isRecording] ) { [self.movieFileOutput stopRecording]; return; } NSDateFormatter * dateFormatter = [[NSDateFormatter alloc] init ]; [dateFormatter setDateFormat:@&quot;yyyyMMddHHmmss&quot;]; NSString * fileName = [[dateFormatter stringFromDate:[NSDate date]] stringByAppendingString:@&quot;.mov&quot;]; NSString * filePath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:fileName]; NSURL *filePathUrl = [NSURL fileURLWithPath:filePath]; //写文件到指定的路径，并设置代理 [self.movieFileOutput startRecordingToOutputFileURL:filePathUrl recordingDelegate:self]; } 设置代理,在视频录制的过程中会发生许多情况，比如说突然来电话，摄像头被其他程序占用，系统会发送相应的通知给我们。 - (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL fromConnections:(NSArray *)connections error:(NSError *)error{ BOOL recordSuccessfully = YES; if ([error code] != noErr) { id value = [[error userInfo] objectForKey:AVErrorRecordingSuccessfullyFinishedKey]; if (value) { recordSuccessfully = [value boolValue]; } } // 有error的话 有可能也是录制成功了 /* AVErrorMaximumDurationReached 时间限制 AVErrorMaximumFileSizeReached 文件大小限制 AVErrorDiskFull 磁盘已满 AVErrorDeviceWasDisconnected device连接失败 AVErrorSessionWasInterrupted 被切断（比如说来电话了） */ }","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}]},{"title":"在centos上搭建git服务器","slug":"在centos上搭建git服务器","date":"2016-05-02T06:35:57.000Z","updated":"2017-12-13T13:09:24.947Z","comments":true,"path":"2016/05/02/在centos上搭建git服务器/","link":"","permalink":"http://yoursite.com/2016/05/02/在centos上搭建git服务器/","excerpt":"刚开始搭建blog的时候打算用ftp的,可是期间遇到了各种问题,最后选择了git,其实现在想想遇到的大部分问题应该全是权限的问题,毕竟对linux的认识只能说算是刚刚起步,等有空的时候再去好好研究吧.","text":"刚开始搭建blog的时候打算用ftp的,可是期间遇到了各种问题,最后选择了git,其实现在想想遇到的大部分问题应该全是权限的问题,毕竟对linux的认识只能说算是刚刚起步,等有空的时候再去好好研究吧. vps(系统centos6.2,git版本1.7) 安装git方法一.yum install -y git(最简单的方法)方法二.下载git源码编译安装,需要安装编译工具(不做介绍) 建立git用户(可选)注意:有些系统在你安装git的时候,可能已经给你自动建立了git用户,因此你可以忽略这一步. 添加git用户 //自动在home下建立git目录 useradd git //切换到/home下查看 ls -al //注意一定要注意查看git目录的拥有者(必须是git)和所属用户组(可以是git或者root), //否则在以后设置免密码clone和push的时候会出现Permission denied error的错误. //修改git目录拥有者和所属群组为git chown -R git:git git 修改git用户的操作权限vi /etc/passwd //找到git用户的那一行,修改如下:不允许git用户的ssh登录 git:x:500:500::/home/git:/usr/bin/git-shell 在服务器上建立裸版本库mkdir /home/testgit //这里 git init 是初始化空仓库的意思，而参数 --bare 是代表创建裸仓库，而参数 --bare 是代表创建裸仓库 git init --bare sample.git 注意:一定要查看testgit目录的拥有者(必须是git)和所属用户组(可以是git或者root),否则在以后设置免密码clone和push的时候会出现Permission denied error的错误. clone远程仓库cd Desktop git clone git@115.159.146.94:/home/testgit/sample.git //这时候会让你输入git的密码,但是我们并没有设置git用户的密码 配置公钥进行免密码登录 clone和pushmac下的公钥和密钥在 ~/.ssh下 cd ~/.ssh ls -a //会看到如下文件(如果没有请查看如何生成公钥和密钥) id_rsa(密钥) id_rsa.pub(公钥) known_host //生成公密钥 终端 ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/home/fdipzone/.ssh/id_rsa): 这里输入要生成的文件名 Enter passphrase (empty for no passphrase): 这里输入密码 Enter same passphrase again: 这里重复输入密码 Your identification has been saved in /home/fdipzone/.ssh/id_rsa. Your public key has been saved in /home/fdipzone/.ssh/id_rsa.pub. The key fingerprint is: f2:76:c3:6b:26:10:14:fc:43:e0:0c:4d:51:c9:a2:b0 The key&#39;s randomart image is: +--[ RSA 2048]----+ | .+=*.. | | . += + | | o oo+ | | E . . o | | ..S. | | .o . | | .o + | | ...oo | | +. | +-----------------+ //密钥生成成功 在centos cd /home/git/.ssh //建立授权文件 authorized_keys,文件不存在则自己新建一个 //将本地机器上的 id_rsa.pub(公钥)里面的复制一份粘贴到centos下/home/git/.ssh/authorized_keys authorized_keys文件看起来是这样的,上下两个免密码登录用户的公钥 ,上下分开. ###注意: .ssh 和 authorized_keys的拥有者必须是git,否则还是会有权限不足的问题 同步代码到自己的博客站点目录比如说我们的博客有一点点的优化,但是push代码之后无法立即查看效果,这个地方我们就需要自动同步就派上用场了。自动同步功能用到的是 git 的钩子功能， cd /home/testgit/sample.git cd hooks //这里我们创建post-receive文件 vi post-receive //在该文件里输入以下内容./home/www就是我blog站点的目录 #!/bin/bash git --work-tree=/home/www checkout -f //保存退出后，将该文件用户及用户组都设置成 gitchown git:git post-receive //由于该文件其实就是一个shell文件，我们还应该为其设置可执行权限 chmod +x post-receive 此时clone自己的blog站点,修改一下网站的名称,push道git服务器,刷新网站首页,是不是发现自己blog的名称变了! 最后再记录一下,配置ssh 免密码登录(so easy)复制自己主机下的公钥内容在自己的vps下 vi /root/.ssh/ authorized_keys //复制密钥内容进去,好了,现在ssh也可以免密码登录了","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"bash","slug":"bash","permalink":"http://yoursite.com/tags/bash/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}]},{"title":"JavaScriptCore的基本用法（一）","slug":"JavaScriptCore的基本用法1","date":"2016-04-07T16:00:00.000Z","updated":"2017-12-30T17:15:18.742Z","comments":true,"path":"2016/04/08/JavaScriptCore的基本用法1/","link":"","permalink":"http://yoursite.com/2016/04/08/JavaScriptCore的基本用法1/","excerpt":"JavaScriptCore简介iOS 7中加入了JavaScriptCore框架。该框架让Objective-C和JavaScript代码直接的交互变得更加的简单方便。而且使得js可以脱离webview与oc交互。","text":"JavaScriptCore简介iOS 7中加入了JavaScriptCore框架。该框架让Objective-C和JavaScript代码直接的交互变得更加的简单方便。而且使得js可以脱离webview与oc交互。在项目中引入JavaScriptCore后，链到头文件中，除了大段的Copyright注释可以看到里面只要引入了5个文件，每个文件里都定义跟文件名对应的类： JSContext和JSValueJSContext//JSVirtualMachine为JavaScript的运行提供了底层资源，JSContext就为其提供着运行环境,该方法用来执行一段 //JS代码，并且如果其中有方法、变量等信息都会被存储在其中以便在需要的时候使用。 - (JSValue *)evaluateScript:(NSString *)script //JSContext的创建都是基于JSVirtualMachine,如果是使用- (id)init; //进行初始化，那么在其内部会自动创建一个新的JSVirtualMachine //对象然后调用前边的初始化方法 - (id)initWithVirtualMachine:(JSVirtualMachine *)virtualMachine; JSValue则可以说是JavaScript和Object-C之间互换的桥梁，它提供了多种方法可以方便地把JavaScript数据类型转换成Objective-C，或者是转换过去。其一一对应方式可见下表： 基本类型的转换JSContext *context = [[JSContext alloc] init]; JSValue *jsVal = [context evaluateScript:@&quot;2+7&quot;]; int iVal = [jsVal toInt32]; NSLog(@&quot;JSValue: %@, int: %d&quot;, jsVal, iVal); //输出9 还可以存一个Js变量在JSContext中，然后通过下标取出来。对于数组或者对象类型，JSValue也可以通过下表直接取值和赋值. [context evaluateScript:@&quot;var arr = [21, 7 ,&#39;leo&#39;]&quot;]; JSValue *value = context[@&quot;arr&quot;]; value[1] = @&quot;blog&quot;; value[7] = @7; NSArray *array = [value toArray]; 打印数组看一下 Printing description of array: &lt;__NSArrayM 0x7fabc144ea40&gt;( 21, blog, leo, &lt;null&gt;, &lt;null&gt;, &lt;null&gt;, &lt;null&gt;, 7 代码成功把数据从OC\u0010赋值到了Js数组上，而且jsValue遵循js数组的特性，无下标越位，自动延展数组大小 方法的转换（js调用oc的第一种方法）各种数据类型可以转换，Objective-C的Block也可以传入JSContext中当做JavaScript的方法使用。 context[@&quot;add&quot;] = ^(NSInteger a, NSInteger b){ //获取该方法的对象 JSValue *v = [JSContext currentThis]; //获取当前的参数 NSArray *args = [JSContext currentArguments]; NSLog(@&quot;当前对象：%@&quot;,v); NSLog(@&quot;当前参数：%@&quot;,args); NSLog(@&quot;和是%ld&quot;,a + b); }; [context evaluateScript:@&quot;add(1,2)&quot;]; 输出如下： 当前对象：GlobalObject 当前参数：( 1, 2) 和是3 上边的例子中对于”this”输出的内容是GlobalObject，这也是JSContext对象方法- (JSValue *)globalObject;所返回的内容。因为我们知道在JavaScript里，所有全局变量和方法其实都是一个全局变量的属性，在浏览器中是window，在JavaScriptCore是什么就不得而知了。 Block可以传入JSContext作方法，但是JSValue没有toBlock方法来把JavaScript方法变成Block在Objetive-C中使用。毕竟Block的参数个数和类型已经返回类型都是固定的。虽然不能把方法提取出来，但是JSValue提供了- (JSValue )callWithArguments:(NSArray )arguments;方法可以反过来将参数传进去来调用方法。 JSContext *context = [[JSContext alloc]init]; NSString *js = @&quot;function add(a,b){return a+ b;}&quot;; [context evaluateScript:js]; JSValue *value = [context[@&quot;add&quot;] callWithArguments:@[@3,@4]]; NSLog(@&quot;%@&quot;,value); 输出如下： 7 JSValue还提供 - (JSValue *)invokeMethod:(NSString *)method withArguments:(NSArray *)arguments; 让我们可以直接简单地调用对象上的方法。只是如果定义的方法是全局函数，那么很显然应该在JSContext的globalObject对象上调用该方法；如果是某JavaScript对象上的方法，就应该用相应的JSValue对象调用。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"JavaScriptCore的基本用法（二）","slug":"JavaScriptCore的基本用法2","date":"2016-04-07T16:00:00.000Z","updated":"2017-12-13T13:09:24.944Z","comments":true,"path":"2016/04/08/JavaScriptCore的基本用法2/","link":"","permalink":"http://yoursite.com/2016/04/08/JavaScriptCore的基本用法2/","excerpt":"这是JavaScriptCore的第二篇","text":"这是JavaScriptCore的第二篇 代理设置（JS调用OC的第二种方法）h文件 //首先写一个协议 遵守JSExport协议 @protocol JSExportTest &lt;JSExport&gt; //宏转换下，将JS函数名称指定为Add； JSExportAs(add, - (NSInteger)add:(NSInteger)a b:(NSInteger)b); @property (nonatomic, assign) NSInteger sum; @end //建一个对象实现这个协议 @interface JSTest : NSObject&lt;JSExportTest&gt; @end m文件 @implementation JSTest @synthesize sum = _sum; //实现协议方法 - (NSInteger)add:(NSInteger)a b:(NSInteger)b{ return a + b; } -(void)setSum:(NSInteger)sum{ NSLog(@&quot;%ld&quot;,(long)sum); _sum = sum; } @end 在viewcontroller里面 JSContext *context = [[JSContext alloc] init]; //设置异常处理 self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) { [JSContext currentContext].exception = exception; NSLog(@&quot;exception:%@&quot;,exception); }; //将obj添加到context中 scontext[@&quot;obj&quot;] = [][JSTest alloc]init]; //JS里面调用obj方法，并将结果赋值给obj的sum属性 [context evaluateScript:@&quot;obj.sum = obj.add(2,3)&quot;]; 在JS中进行调用这个对象的方法，并将结果赋值sum。唯一要注意的是OC的函数命名和JS函数命名规则问题。协议中定义的是add: b:，但是JS里面方法名字是add(a,b)。可以通过JSExportAs这个宏转换成JS的函数名字。 异常处理Objective-C的异常会在运行时被Xcode捕获，而在JSContext中执行的JavaScript如果出现异常，只会被JSContext捕获并存储在exception属性上，而不会向外抛出。时时刻刻检查JSContext对象的exception是否不为nil显然是不合适，更合理的方式是给JSContext对象设置exceptionHandler，它接受的是^(JSContext *context, JSValue *exceptionValue)形式的Block。其默认值就是将传入的exceptionValue赋给传入的context的exception属性： JSContext *context = [[JSContext alloc] init]; context.exceptionHandler = ^(JSContext *con, JSValue *exception) { NSLog(@&quot;%@&quot;, exception); con.exception = exception; }; [context evaluateScript:@&quot;fengzhen = 66&quot;]; //输出: // ReferenceError: Can&#39;t find variable: fengzhen 无论是把Block传给JSContext对象让其变成avaScript方法，还是把它赋给exceptionHandler属性，在Block内都不要直接使用其外部定义的JSContext对象或者JSValue，应该将其当做参数传入到Block中，或者通过JSContext的类方法+ (JSContext *)currentContext;来获得。否则会造成循环引用使得内存无法被正确释放。 内存管理OC使用的是ARC，JS使用的是垃圾回收机制，js的引用全都是强引用，垃圾回收机制会帮他们打破这种强引用，所以JS不存在循环引用的问题。一般情况下，OC和JS对象之间内存管理都无需我们去关心。不过还是有几个注意点需要我们去留意下。 不要在block里面直接使用context，或者使用外部的JSValue对象。JSContext *context = [[JSContext alloc] init]; //设置异常处理 self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) { //直接这么使用是错误的 //context.exception = exception; [JSContext currentContext].exception = exception; NSLog(@&quot;exception:%@&quot;,exception); }; OC对象不要用属性直接保存JSValue对象，因为这样太容易造成循环引用。下面的例子： #import &lt;Foundation/Foundation.h&gt; #import &lt;JavaScriptCore/JavaScriptCore.h&gt; //首先写一个协议 遵守JSExport协议 @protocol JSExportTest &lt;JSExport&gt; //宏转换下，将JS函数名称指定为Add； JSExportAs(add, - (NSInteger)add:(NSInteger)a b:(NSInteger)b); @property (nonatomic, strong) JSValue *value; @end //建一个对象实现这个协议 @interface JSTest : NSObject&lt;JSExportTest&gt; @end #import &quot;JSTest.h&quot; @implementation JSTest @synthesize value = _value; //实现协议方法 -(void)setValue:(JSValue *)value{ _value = value; } @end viewController里面 JSContext *context = [[JSContext alloc]init]; context.exceptionHandler = ^(JSContext *j, JSValue *v){ NSLog(@&quot;%@&quot;,j.exception); }; [context evaluateScript:@&quot;function callback(){return &#39;hello world&#39;};function setObj(obj){this.obj = obj;obj.value = callback}&quot;]; [context[@&quot;setObj&quot;] callWithArguments:@[self.testObj]]; 调用JS方法，进行赋值，JS对象保留了传进来的obj，最后，JS将自己的回调callback赋值给了obj，方便obj下次回调给JS；由于JS那边保存了obj，而且obj这边也保留了JS的回调。这样就形成了循环引用。为了打破这种强引用，apple有一个JSManagedValue 的类，官方的原话： The JSManagedValue&#39;s JavaScript value is reachable from JavaScript The owner of the managed reference is reachable in Objective-C. Manually adding or removing the managed reference in the JSVirtualMachine determines reachability. JSManagedValue 帮助我们保存JSValue，里面保存的JS对象必须在JS中存在，同时 JSManagedValue 的owner在OC中也存在.因此我们把代理的m文件修改如下： -(void)setValue:(JSValue *)value{ // 由于是回掉的关系 obj保存了JS的回掉， js也保存了obj，这样就形成了循环引用 // JSManageValue帮助我们保存了JSValue，哪里保存的js对象在js中存在。 JSMangerValue的owner在OC中也存在。 JSManagedValue *mavalue = [JSManagedValue managedValueWithValue:value]; //建立弱引用关系 [[[JSContext currentContext] virtualMachine] addManagedReference:mavalue withOwner:self]; _value = value; } 不要在不同的 JSVirtualMachine 之间进行传递JS对象。一个JSVirtualMachine可以运行多个context，由于都是在同一个堆内存和同一个垃圾回收下，所以相互之间传值是没问题的。但是如果在不同的 JSVirtualMachine传值，垃圾回收就不知道他们之间的关系了，可能会引起异常。 JavaScriptCore线程是安全的。每个context运行的时候通过lock关联的JSVirtualMachine。如果要进行并发操作，可以创建多个JSVirtualMachine实例进行操作。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]}]}