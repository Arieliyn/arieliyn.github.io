<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-30T14:50:10.577Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/12/30/hello-world/"/>
    <id>http://yoursite.com/2017/12/30/hello-world/</id>
    <published>2017-12-30T14:50:10.577Z</published>
    <updated>2017-12-30T14:50:10.577Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python学习笔记（一）</title>
    <link href="http://yoursite.com/2017/07/19/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/07/19/Python学习笔记（一）/</id>
    <published>2017-07-19T01:44:20.000Z</published>
    <updated>2017-12-13T13:09:24.946Z</updated>
    
    <content type="html"><![CDATA[<p><strong>除法</strong>   </p><ol><li>X / Y  2.6之前的版本会省去小数部分，3版本之后无论任何类型都会保持小数部分。  </li><li>X // Y  Floor除法，不管哪个版本，总是省略小数部分,也称为截断除法，结果会向下舍入  </li></ol><pre><code class="py">    import math    print(math.floor(-2.5)) //输出-3 （向下舍入）    print(math.floor(2.5)) //输出2 （向下舍入）    print(math.trunc(5 / -2))//输出-2    print(math.trunc(5 / 2))//输出2</code></pre><p>如果你真的只想截断，而不管符号，可以通过<code>math.trunc</code>来得到一个浮点除法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;除法&lt;/strong&gt;   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;X / Y  2.6之前的版本会省去小数部分，3版本之后无论任何类型都会保持小数部分。  &lt;/li&gt;
&lt;li&gt;X // Y  Floor除法，不管哪个版本，总是省略小数部分,也称为截断除法，结果会向下舍
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Mac搭建PHP开发环境</title>
    <link href="http://yoursite.com/2017/05/03/Mac%E6%90%AD%E5%BB%BAPHP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2017/05/03/Mac搭建PHP开发环境/</id>
    <published>2017-05-03T01:05:57.000Z</published>
    <updated>2017-12-13T13:09:24.946Z</updated>
    
    <content type="html"><![CDATA[<p><code>Mac</code>搭建<code>PHP</code>开发环境(<code>mamp</code>+<code>phpstorm</code>+<code>xdebug</code>)<br><a id="more"></a></p><h4 id="OS版本"><a href="#OS版本" class="headerlink" title="OS版本"></a>OS版本</h4><hr><p><img src="http://upload-images.jianshu.io/upload_images/1043168-77c8023387b75a0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h4 id="一-首先下载搭建环境所需要的软件"><a href="#一-首先下载搭建环境所需要的软件" class="headerlink" title="一.首先下载搭建环境所需要的软件"></a>一.首先下载搭建环境所需要的软件</h4><p>1.<a href="http://pan.baidu.com/s/1kUShXXH" target="_blank" rel="noopener">phpstorm</a> 密码: jebr<br>2.<a href="http://pan.baidu.com/s/1cAzFbC" target="_blank" rel="noopener">mamp pro</a>密码: mhia<br>3.<code>chrome</code><br>4.JetBrains IDE Support(chrome插件)</p><h4 id="二-安装成功之后配置mamp"><a href="#二-安装成功之后配置mamp" class="headerlink" title="二.安装成功之后配置mamp"></a>二.安装成功之后配置mamp</h4><h5 id="新建一个server目录"><a href="#新建一个server目录" class="headerlink" title="新建一个server目录"></a>新建一个server目录</h5><p><img src="http://upload-images.jianshu.io/upload_images/1043168-9107bcd5b20e92fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>默认会生成以下两个文件</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-0dc20a4ec6ec7c39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h5 id="mamp是自带xdebug的-因此我们不需要brew来安装xdebug-直接启用"><a href="#mamp是自带xdebug的-因此我们不需要brew来安装xdebug-直接启用" class="headerlink" title="mamp是自带xdebug的,因此我们不需要brew来安装xdebug,直接启用"></a>mamp是自带xdebug的,因此我们不需要brew来安装xdebug,直接启用</h5><p><img src="http://upload-images.jianshu.io/upload_images/1043168-de5ea90e78910a16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>启动serve之后默认会跳转mamp的信息界面</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-78f92245a8c95bb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>点击菜单栏的phpinfo,边可以看到php的相关配置</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-c7221e100e227a21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png">然后再</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-c72e6f06475911ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h4 id="三-配置phpstorm"><a href="#三-配置phpstorm" class="headerlink" title="三.配置phpstorm"></a>三.配置phpstorm</h4><p>删掉index.php的所有代码输入一段测试代码</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-e64e93dfc98312ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>配置项目的运行环境<br><img src="http://upload-images.jianshu.io/upload_images/1043168-f01486f4c74b90ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>选择php位置</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-7238d1a2be375612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>然后apply  ok<br>修改端口</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-2e9ec88b288666c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>配置DBCpProxy<br><img src="http://upload-images.jianshu.io/upload_images/1043168-ac0179546718cf5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-ed739d041ff7c1b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-fbaacaee82cc7a4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h4 id="四-chromeJetBrains-IDE-Support-Chrome插件并启用"><a href="#四-chromeJetBrains-IDE-Support-Chrome插件并启用" class="headerlink" title="四.chromeJetBrains IDE Support Chrome插件并启用"></a>四.chrome<a href="http://www.cnplugins.com/devtool/jetbrains-ide-support/download.html" target="_blank" rel="noopener">JetBrains IDE Support Chrome插件</a>并启用</h4><h4 id="五-打断点调试"><a href="#五-打断点调试" class="headerlink" title="五.打断点调试"></a>五.打断点调试</h4><p><img src="http://upload-images.jianshu.io/upload_images/1043168-3c54ec7f5a75bed9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Mac&lt;/code&gt;搭建&lt;code&gt;PHP&lt;/code&gt;开发环境(&lt;code&gt;mamp&lt;/code&gt;+&lt;code&gt;phpstorm&lt;/code&gt;+&lt;code&gt;xdebug&lt;/code&gt;)&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="MAC" scheme="http://yoursite.com/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>雨后</title>
    <link href="http://yoursite.com/2017/05/03/%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2017/05/03/思考/</id>
    <published>2017-05-03T01:05:57.000Z</published>
    <updated>2017-12-13T13:09:24.947Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>视频</title>
    <link href="http://yoursite.com/2017/05/03/%E4%B8%89%E4%B8%AAmd/"/>
    <id>http://yoursite.com/2017/05/03/三个md/</id>
    <published>2017-05-03T01:05:57.000Z</published>
    <updated>2017-12-30T14:50:12.933Z</updated>
    
    <content type="html"><![CDATA[<p>###一、UIImagePickerController<br><code>UIImagePickerController</code>是<code>UIKit</code>框架里面的一个class，通过这个系统提供的class我们可以简单的是实现拍照、录制视频和音频。   </p><h5 id="三个步骤："><a href="#三个步骤：" class="headerlink" title="三个步骤："></a>三个步骤：</h5><blockquote><ol><li>当前控制器<code>present</code>一个<code>UIImagePickerController</code>类   </li><li>在当前界面就可以拍照、录制视频和音频    </li><li>实现<code>UIImagePickerController</code>的<code>delegate</code>，在<code>delegate</code>可以获取录制的视频和音频，来进行相应的操作.   </li></ol></blockquote><h5 id="定制化UIImagePickerController"><a href="#定制化UIImagePickerController" class="headerlink" title="定制化UIImagePickerController"></a>定制化UIImagePickerController</h5><pre><code class="objc">//    查看摄像头是否可用if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera] == NO) {     return;}UIImagePickerController *imagePick = [[UIImagePickerController alloc]init];imagePick.sourceType = UIImagePickerControllerSourceTypeCamera;//    我们还可以设置照片和视频拍摄的质量、是否可以开启闪光灯、是否开启手电筒//    还可以单独设置只支持视频模式//    imagePick.mediaTypes = [[NSArray alloc] initWithObjects: (NSString *) kUTTypeMovie, nil];imagePick.mediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];//    UINavigationControllerDelegate,UIImagePickerControllerDelegate;imagePick.delegate = self;//拍照或者录制结束后是否可以编辑imagePick.allowsEditing = NO;[self presentViewController:imagePick animated:YES completion:nil];</code></pre><h5 id="界面的自定义"><a href="#界面的自定义" class="headerlink" title="界面的自定义"></a>界面的自定义</h5><p><code>cameraOverlayView</code>属性可以自定义<code>UIImagePickerController</code>界面顶部的控件，但是只在<code>UIImagePickerController</code>的<code>mediaTypes</code>为<code>UIImagePickerControllerSourceTypeCamera</code>时可用。   </p><h5 id="实现UIImagePickerController的delegate"><a href="#实现UIImagePickerController的delegate" class="headerlink" title="实现UIImagePickerController的delegate"></a>实现<code>UIImagePickerController</code>的<code>delegate</code></h5><pre><code class="objectivec">- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info{    NSString *mediaType = [info objectForKey:UIImagePickerControllerMediaType];     UIImage *originalImage, *editedImage, *imageToSave;    //    处理图片    if ([mediaType isEqualToString:(NSString *)kUTTypeImage]) {        editedImage = info[UIImagePickerControllerOriginalImage];        originalImage = info[UIImagePickerControllerEditedImage];        if (editedImage) {            imageToSave = editedImage;        }else{            imageToSave = originalImage;        }        UIImageWriteToSavedPhotosAlbum(imageToSave, nil, nil, nil);    }    //处理视频    if ([mediaType isEqualToString:(NSString *)kUTTypeMovie]) {        NSString *url = [info[UIImagePickerControllerMediaURL] path];        if (UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(url)) {            UISaveVideoAtPathToSavedPhotosAlbum(url, nil, nil, nil);        }    }    [picker dismissViewControllerAnimated:YES completion:nil];}</code></pre><p>###二、AVCaptureSession &amp; AVCaptureMovieFileOutput<br>  要获取摄像机捕捉到的视频或者麦克风捕捉到的音频，我们需要对象表示inputs和outputs，并使用AVCaptureSession的实例来协调它们之间的数据流。   </p><blockquote><ol><li>AVCaptureDevice 对象，表示声音或者视频采集设备，对应摄像头和麦克风。</li><li>AVCaptureInput的子类，配置输入端口。</li><li>AVCaptureOutput的子类， 输出采集到的视频或者图像。</li><li>AVCaptureSession来协调从输入到输出的数据流。</li></ol></blockquote><p>#####步骤一： 创建AVCaptureDevice 对象<br>因为我们需要录制视频和音频所以我们需要视频的AVCaptureDevice和音频的AVCaptureDevice。   </p><pre><code class="objc">//我们同时获取了前摄像头和后摄像头因为等会我们要手动切换//获取音频device-(AVCaptureDevice *)audioDevice{    if (!_audioDevice) {        _audioDevice = [AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio].firstObject;    }    return _audioDevice;}   //后置摄像头-(AVCaptureDevice *)backVideoDevice{    if (!_backVideoDevice) {        _backVideoDevice = [self getDeviceBy:AVCaptureDevicePositionBack];        if ([self.currentVideoDevice isTorchAvailable] &amp;&amp; [_backVideoDevice isTorchModeSupported:AVCaptureTorchModeOn]) {            //可以设置是否开启闪光灯，是否开始HDR、视频防抖、白平衡什么的            //设置device之前需要先 lockForConfiguration             if ([_backVideoDevice lockForConfiguration:NULL]==YES) {                self.currentVideoDevice.torchMode = AVCaptureTorchModeOn;                [self.currentVideoDevice unlockForConfiguration];            }        }    }    }    return _backVideoDevice;}//前置摄像头-(AVCaptureDevice *)frontVideoDevice{    if (!_frontVideoDevice) {        _frontVideoDevice = [self getDeviceBy:AVCaptureDevicePositionFront];    }    return _frontVideoDevice;}</code></pre><p>#####步骤二、配置inputs<br>每个AVCaptureDevice对应一个input。   </p><pre><code class="objc">//audio input- (AVCaptureDeviceInput *)audioInput{    if (!_audioInput) {        NSError *error = nil;        _audioInput = [AVCaptureDeviceInput deviceInputWithDevice:self.audioDevice error:&amp;error];    }    return _audioInput;}- (AVCaptureDeviceInput *)videoInput{    if (!_videoInput) {        NSError *error  = nil;        _videoInput = [AVCaptureDeviceInput deviceInputWithDevice:self.currentVideoDevice error:&amp;error];    }    return _videoInput;}</code></pre><p>#####步骤三: 写入文件<br>Output有四种：</p><blockquote><p><code>AVCaptureMovieFileOutput</code> 写入文件<br><code>AVCaptureVideoDataOutput</code> 加工视频输出<br><code>AVCaptureAudioDataOutput</code> 加工音频输出<br><code>AVCaptureStillImageOutput</code> 捕捉输出的图像</p></blockquote><p>写入文件只需要AVCaptureMovieFileOutput就可以了。   </p><pre><code class="objc">// output- (AVCaptureMovieFileOutput  *)movieFileOutput{    if (!_movieFileOutput) {        _movieFileOutput = [[AVCaptureMovieFileOutput  alloc]init];        //CMTime drution = CMTimeMake(1, 60);        //设置视频录制时间限制 kCMTimeInvalid(无限制)        _movieFileOutput.maxRecordedDuration = kCMTimeInvalid;        // 文件大小限制        //_movieFileOutput.maxRecordedFileSize = 1024 * 1024;        AVCaptureConnection *videoConnection = [_movieFileOutput connectionWithMediaType:AVMediaTypeVideo];        // 是否支持科学防抖        if ([videoConnection isVideoStabilizationSupported]) {            videoConnection.preferredVideoStabilizationMode = AVCaptureVideoStabilizationModeAuto;        }        videoConnection.videoOrientation = self.previewLayer.connection.videoOrientation;    }    return _movieFileOutput;}</code></pre><p>#####步骤四： 获取AVCaptureSession </p><pre><code class="objc">- (AVCaptureSession *)session{    if (!_session) {        _session = [[AVCaptureSession alloc]init];        // 设置视频质量        if ([_session canSetSessionPreset:AVCaptureSessionPresetLow]) {            [_session setSessionPreset:AVCaptureSessionPresetLow];        }        //增加videoinput        if ([_session canAddInput:self.videoInput]) {            [_session addInput:self.videoInput];        }        //增加videoinput        if ([_session canAddInput:self.audioInput]) {            [_session addInput:self.audioInput];        }        //增加fileOutput        if ([_session canAddOutput:self.movieFileOutput]) {            [_session addOutput:self.movieFileOutput];        }    }    return _session;}</code></pre><p>这个地方需要注意下，每次我们更改AVCaptureSession的属性的时候我们都需要：   </p><pre><code class="objc">[session beginConfiguration];// Remove an existing capture device.// Add a new capture device.// Reset the preset.[session commitConfiguration];</code></pre><h5 id="现在就可以录制视频并写入文件了"><a href="#现在就可以录制视频并写入文件了" class="headerlink" title="现在就可以录制视频并写入文件了"></a>现在就可以录制视频并写入文件了</h5><p>为了实时查看我们录制的内容，我们加一个预览层。   </p><pre><code class="objc">-(AVCaptureVideoPreviewLayer *)previewLayer{    if (!_previewLayer) {        _previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session];        _previewLayer.frame = [UIScreen mainScreen].bounds;        _previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill;        _previewLayer.connection.videoOrientation = AVCaptureVideoOrientationPortrait;    }    return _previewLayer;}</code></pre><p>在控制器里面调用session的startRuning方法，这个时候只是采集到了视频显示在了预览层上面，并未开始录制。</p><pre><code class="objc">- (void)viewDidLoad {    [super viewDidLoad];    self.recodingView.delegate = self;    [self.view.layer insertSublayer:self.previewLayer atIndex:0];    [self.session startRunning];}</code></pre><p>点击录制视频,recodingView是我自定义的控件。   </p><pre><code class="objc">-(void)writePath{    if ([self.movieFileOutput isRecording] ) {        [self.movieFileOutput stopRecording];        return;    }    NSDateFormatter * dateFormatter = [[NSDateFormatter alloc] init ];    [dateFormatter setDateFormat:@&quot;yyyyMMddHHmmss&quot;];    NSString * fileName = [[dateFormatter stringFromDate:[NSDate date]] stringByAppendingString:@&quot;.mov&quot;];    NSString * filePath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:fileName];    NSURL *filePathUrl = [NSURL fileURLWithPath:filePath];    //写文件到指定的路径，并设置代理    [self.movieFileOutput startRecordingToOutputFileURL:filePathUrl recordingDelegate:self];}</code></pre><p>设置代理,在视频录制的过程中会发生许多情况，比如说突然来电话，摄像头被其他程序占用，系统会发送相应的通知给我们。</p><pre><code class="objc">- (void)captureOutput:(AVCaptureFileOutput *)captureOutputdidFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL      fromConnections:(NSArray *)connections                error:(NSError *)error{    BOOL recordSuccessfully = YES;    if ([error code] != noErr) {        id value = [[error userInfo] objectForKey:AVErrorRecordingSuccessfullyFinishedKey];        if (value) {            recordSuccessfully = [value boolValue];        }    }//   有error的话 有可能也是录制成功了    /*    AVErrorMaximumDurationReached  时间限制    AVErrorMaximumFileSizeReached  文件大小限制    AVErrorDiskFull                磁盘已满    AVErrorDeviceWasDisconnected   device连接失败    AVErrorSessionWasInterrupted   被切断（比如说来电话了）*/}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###一、UIImagePickerController&lt;br&gt;&lt;code&gt;UIImagePickerController&lt;/code&gt;是&lt;code&gt;UIKit&lt;/code&gt;框架里面的一个class，通过这个系统提供的class我们可以简单的是实现拍照、录制视频和音频。  
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>在centos上搭建git服务器</title>
    <link href="http://yoursite.com/2016/05/02/%E5%9C%A8centos%E4%B8%8A%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2016/05/02/在centos上搭建git服务器/</id>
    <published>2016-05-02T06:35:57.000Z</published>
    <updated>2017-12-13T13:09:24.947Z</updated>
    
    <content type="html"><![CDATA[<p>  刚开始搭建blog的时候打算用ftp的,可是期间遇到了各种问题,最后选择了git,其实现在想想遇到的大部分问题应该全是权限的问题,毕竟对linux的认识只能说算是刚刚起步,等有空的时候再去好好研究吧.<br>  <a id="more"></a></p><h3 id="vps-系统centos6-2-git版本1-7"><a href="#vps-系统centos6-2-git版本1-7" class="headerlink" title="vps(系统centos6.2,git版本1.7)"></a>vps(系统centos6.2,git版本1.7)</h3><hr><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装<code>git</code></h4><p>方法一.<code>yum install -y git</code>(最简单的方法)<br>方法二.下载<code>git</code>源码编译安装,需要安装编译工具(不做介绍)</p><h4 id="建立git用户-可选"><a href="#建立git用户-可选" class="headerlink" title="建立git用户(可选)"></a>建立<code>git</code>用户(可选)</h4><p>注意:有些系统在你安装<code>git</code>的时候,可能已经给你自动建立了<code>git</code>用户,因此你可以忽略这一步.</p><p>添加git用户</p><pre><code class="bash">//自动在home下建立git目录useradd git//切换到/home下查看ls -al//注意一定要注意查看git目录的拥有者(必须是git)和所属用户组(可以是git或者root),//否则在以后设置免密码clone和push的时候会出现Permission denied error的错误.//修改git目录拥有者和所属群组为gitchown -R git:git git</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1043168-62019d6ea599afa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="F9D26F43-5BBE-4C51-8E72-8F94171EBD94.png"></p><h4 id="修改git用户的操作权限"><a href="#修改git用户的操作权限" class="headerlink" title="修改git用户的操作权限"></a>修改<code>git</code>用户的操作权限</h4><pre><code class="bash">vi /etc/passwd//找到git用户的那一行,修改如下:不允许git用户的ssh登录git:x:500:500::/home/git:/usr/bin/git-shell</code></pre><h4 id="在服务器上建立裸版本库"><a href="#在服务器上建立裸版本库" class="headerlink" title="在服务器上建立裸版本库"></a>在服务器上建立裸版本库</h4><pre><code class="bash">mkdir /home/testgit//这里 git init 是初始化空仓库的意思，而参数 --bare 是代表创建裸仓库，而参数 --bare 是代表创建裸仓库git init --bare sample.git注意:一定要查看testgit目录的拥有者(必须是git)和所属用户组(可以是git或者root),否则在以后设置免密码clone和push的时候会出现Permission denied error的错误.</code></pre><h4 id="clone远程仓库"><a href="#clone远程仓库" class="headerlink" title="clone远程仓库"></a><code>clone</code>远程仓库</h4><pre><code class="bash">cd Desktopgit clone git@115.159.146.94:/home/testgit/sample.git //这时候会让你输入git的密码,但是我们并没有设置git用户的密码</code></pre><h4 id="配置公钥进行免密码登录-clone和push"><a href="#配置公钥进行免密码登录-clone和push" class="headerlink" title="配置公钥进行免密码登录 clone和push"></a>配置公钥进行免密码登录 clone和push</h4><p>mac下的公钥和密钥在 ~/.ssh下</p><pre><code class="bash">cd ~/.sshls -a//会看到如下文件(如果没有请查看如何生成公钥和密钥)id_rsa(密钥)   id_rsa.pub(公钥)  known_host//生成公密钥 终端ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/home/fdipzone/.ssh/id_rsa): 这里输入要生成的文件名Enter passphrase (empty for no passphrase): 这里输入密码 Enter same passphrase again: 这里重复输入密码Your identification has been saved in /home/fdipzone/.ssh/id_rsa.Your public key has been saved in /home/fdipzone/.ssh/id_rsa.pub.The key fingerprint is:f2:76:c3:6b:26:10:14:fc:43:e0:0c:4d:51:c9:a2:b0The key&#39;s randomart image is:+--[ RSA 2048]----+|    .+=*..                  ||    . += +                  || o oo+ || E . . o || ..S. || .o . || .o + || ...oo || +. |+-----------------+//密钥生成成功</code></pre><p>在centos</p><pre><code class="bash">cd /home/git/.ssh//建立授权文件 authorized_keys,文件不存在则自己新建一个//将本地机器上的 id_rsa.pub(公钥)里面的复制一份粘贴到centos下/home/git/.ssh/authorized_keys</code></pre><p>authorized_keys文件看起来是这样的,上下两个免密码登录用户的公钥 ,上下分开.</p><p>###注意:  .ssh  和 authorized_keys的拥有者必须是git,否则还是会有权限不足的问题<br><img src="http://upload-images.jianshu.io/upload_images/1043168-f05cb1189bd5290f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h4 id="同步代码到自己的博客站点目录"><a href="#同步代码到自己的博客站点目录" class="headerlink" title="同步代码到自己的博客站点目录"></a>同步代码到自己的博客站点目录</h4><p>比如说我们的博客有一点点的优化,但是push代码之后无法立即查看效果,这个地方我们就需要自动同步就派上用场了。自动同步功能用到的是 git 的钩子功能，</p><pre><code class="bash">cd /home/testgit/sample.gitcd hooks//这里我们创建post-receive文件vi post-receive//在该文件里输入以下内容./home/www就是我blog站点的目录#!/bin/bashgit --work-tree=/home/www checkout -f//保存退出后，将该文件用户及用户组都设置成gitchown git:git post-receive//由于该文件其实就是一个shell文件，我们还应该为其设置可执行权限chmod +x post-receive</code></pre><p>此时clone自己的blog站点,修改一下网站的名称,push道git服务器,刷新网站首页,是不是发现自己blog的名称变了!</p><h4 id="最后再记录一下-配置ssh-免密码登录-so-easy"><a href="#最后再记录一下-配置ssh-免密码登录-so-easy" class="headerlink" title="最后再记录一下,配置ssh 免密码登录(so easy)"></a>最后再记录一下,配置ssh 免密码登录(so easy)</h4><p>复制自己主机下的公钥内容<br>在自己的vps下</p><pre><code class="bash">vi  /root/.ssh/ authorized_keys</code></pre><p>//复制密钥内容进去,好了,现在ssh也可以免密码登录了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  刚开始搭建blog的时候打算用ftp的,可是期间遇到了各种问题,最后选择了git,其实现在想想遇到的大部分问题应该全是权限的问题,毕竟对linux的认识只能说算是刚刚起步,等有空的时候再去好好研究吧.&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="bash" scheme="http://yoursite.com/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>JavaScriptCore的基本用法（一）</title>
    <link href="http://yoursite.com/2016/04/08/JavaScriptCore%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%951/"/>
    <id>http://yoursite.com/2016/04/08/JavaScriptCore的基本用法1/</id>
    <published>2016-04-07T16:00:00.000Z</published>
    <updated>2017-12-30T17:15:18.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScriptCore简介"><a href="#JavaScriptCore简介" class="headerlink" title="JavaScriptCore简介"></a>JavaScriptCore简介</h3><p>iOS 7中加入了<code>JavaScriptCore</code>框架。该框架让<code>Objective-C</code>和<code>JavaScript</code>代码直接的交互变得更加的简单方便。而且使得js可以脱离webview与oc交互。<br><a id="more"></a><br>在项目中引入JavaScriptCore后，链到头文件中，除了大段的Copyright注释可以看到里面只要引入了5个文件，每个文件里都定义跟文件名对应的类：<br><img src="./JavaScriptCore的基本用法1/logo.png" alt="JavaScriptCore"></p><h4 id="JSContext和JSValue"><a href="#JSContext和JSValue" class="headerlink" title="JSContext和JSValue"></a>JSContext和JSValue</h4><h5 id="JSContext"><a href="#JSContext" class="headerlink" title="JSContext"></a>JSContext</h5><pre><code class="mm">//JSVirtualMachine为JavaScript的运行提供了底层资源，JSContext就为其提供着运行环境,该方法用来执行一段//JS代码，并且如果其中有方法、变量等信息都会被存储在其中以便在需要的时候使用。- (JSValue *)evaluateScript:(NSString *)script//JSContext的创建都是基于JSVirtualMachine,如果是使用- (id)init;//进行初始化，那么在其内部会自动创建一个新的JSVirtualMachine//对象然后调用前边的初始化方法- (id)initWithVirtualMachine:(JSVirtualMachine *)virtualMachine;</code></pre><h5 id="JSValue"><a href="#JSValue" class="headerlink" title="JSValue"></a>JSValue</h5><p>则可以说是JavaScript和Object-C之间互换的桥梁，它提供了多种方法可以方便地把JavaScript数据类型转换成Objective-C，或者是转换过去。其一一对应方式可见下表：<br><img src="JavaScriptCore的基本用法1/javaScriptCoreObject.jpeg" alt="JavaScript对象和OC对象的对应关系"></p><h3 id="基本类型的转换"><a href="#基本类型的转换" class="headerlink" title="基本类型的转换"></a>基本类型的转换</h3><pre><code class="mm">JSContext *context = [[JSContext alloc] init];JSValue *jsVal = [context evaluateScript:@&quot;2+7&quot;];int iVal = [jsVal toInt32];NSLog(@&quot;JSValue: %@, int: %d&quot;, jsVal, iVal);//输出9</code></pre><p>还可以存一个Js变量在JSContext中，然后通过下标取出来。对于数组或者对象类型，JSValue也可以通过下表直接取值和赋值.</p><pre><code class="objc">[context evaluateScript:@&quot;var arr = [21, 7 ,&#39;leo&#39;]&quot;];JSValue *value = context[@&quot;arr&quot;];value[1] = @&quot;blog&quot;;value[7] = @7;NSArray *array = [value toArray];打印数组看一下Printing description of array:&lt;__NSArrayM 0x7fabc144ea40&gt;(21,blog,leo,&lt;null&gt;,&lt;null&gt;,&lt;null&gt;,&lt;null&gt;,7</code></pre><p>代码成功把数据从OC赋值到了Js数组上，而且jsValue遵循js数组的特性，无下标越位，自动延展数组大小</p><h3 id="方法的转换（js调用oc的第一种方法）"><a href="#方法的转换（js调用oc的第一种方法）" class="headerlink" title="方法的转换（js调用oc的第一种方法）"></a>方法的转换（js调用oc的第一种方法）</h3><p>各种数据类型可以转换，Objective-C的Block也可以传入JSContext中当做JavaScript的方法使用。</p><pre><code class="objc">context[@&quot;add&quot;] = ^(NSInteger a, NSInteger b){//获取该方法的对象JSValue *v = [JSContext currentThis];//获取当前的参数NSArray *args = [JSContext currentArguments];NSLog(@&quot;当前对象：%@&quot;,v);NSLog(@&quot;当前参数：%@&quot;,args);NSLog(@&quot;和是%ld&quot;,a + b);};[context evaluateScript:@&quot;add(1,2)&quot;];输出如下：当前对象：GlobalObject当前参数：(1,2)和是3</code></pre><p>上边的例子中对于”this”输出的内容是GlobalObject，这也是JSContext对象方法- (JSValue *)globalObject;所返回的内容。因为我们知道在JavaScript里，所有全局变量和方法其实都是一个全局变量的属性，在浏览器中是window，在JavaScriptCore是什么就不得而知了。</p><p>Block可以传入JSContext作方法，但是JSValue没有toBlock方法来把JavaScript方法变成Block在Objetive-C中使用。毕竟Block的参数个数和类型已经返回类型都是固定的。虽然不能把方法提取出来，但是JSValue提供了- (JSValue <em>)callWithArguments:(NSArray </em>)arguments;方法可以反过来将参数传进去来调用方法。</p><pre><code class="objc">JSContext *context = [[JSContext alloc]init];NSString *js = @&quot;function add(a,b){return a+ b;}&quot;;[context evaluateScript:js];JSValue *value = [context[@&quot;add&quot;] callWithArguments:@[@3,@4]];NSLog(@&quot;%@&quot;,value);输出如下：7</code></pre><p>JSValue还提供</p><pre><code class="objc">- (JSValue *)invokeMethod:(NSString *)method withArguments:(NSArray *)arguments;</code></pre><p>让我们可以直接简单地调用对象上的方法。只是如果定义的方法是全局函数，那么很显然应该在JSContext的globalObject对象上调用该方法；如果是某JavaScript对象上的方法，就应该用相应的JSValue对象调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JavaScriptCore简介&quot;&gt;&lt;a href=&quot;#JavaScriptCore简介&quot; class=&quot;headerlink&quot; title=&quot;JavaScriptCore简介&quot;&gt;&lt;/a&gt;JavaScriptCore简介&lt;/h3&gt;&lt;p&gt;iOS 7中加入了&lt;code&gt;JavaScriptCore&lt;/code&gt;框架。该框架让&lt;code&gt;Objective-C&lt;/code&gt;和&lt;code&gt;JavaScript&lt;/code&gt;代码直接的交互变得更加的简单方便。而且使得js可以脱离webview与oc交互。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScriptCore的基本用法（二）</title>
    <link href="http://yoursite.com/2016/04/08/JavaScriptCore%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%952/"/>
    <id>http://yoursite.com/2016/04/08/JavaScriptCore的基本用法2/</id>
    <published>2016-04-07T16:00:00.000Z</published>
    <updated>2017-12-13T13:09:24.944Z</updated>
    
    <content type="html"><![CDATA[<p>  这是<code>JavaScriptCore</code>的第二篇<br><a id="more"></a></p><h3 id="代理设置（JS调用OC的第二种方法）"><a href="#代理设置（JS调用OC的第二种方法）" class="headerlink" title="代理设置（JS调用OC的第二种方法）"></a>代理设置（<code>JS</code>调用<code>OC</code>的第二种方法）</h3><p><code>h文件</code></p><pre><code class="objc">//首先写一个协议  遵守JSExport协议@protocol JSExportTest &lt;JSExport&gt;//宏转换下，将JS函数名称指定为Add；JSExportAs(add, - (NSInteger)add:(NSInteger)a b:(NSInteger)b);@property (nonatomic, assign) NSInteger sum;@end//建一个对象实现这个协议@interface JSTest : NSObject&lt;JSExportTest&gt;@end</code></pre><p><code>m文件</code></p><pre><code class="objc">@implementation JSTest@synthesize sum = _sum;//实现协议方法- (NSInteger)add:(NSInteger)a b:(NSInteger)b{return a + b;}-(void)setSum:(NSInteger)sum{NSLog(@&quot;%ld&quot;,(long)sum);_sum = sum;}@end</code></pre><p>在viewcontroller里面</p><pre><code class="objc">JSContext *context = [[JSContext alloc] init];//设置异常处理self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) {[JSContext currentContext].exception = exception;NSLog(@&quot;exception:%@&quot;,exception);};//将obj添加到context中scontext[@&quot;obj&quot;] = [][JSTest alloc]init];//JS里面调用obj方法，并将结果赋值给obj的sum属性[context evaluateScript:@&quot;obj.sum = obj.add(2,3)&quot;];</code></pre><p>在<code>JS</code>中进行调用这个对象的方法，并将结果赋值<code>sum</code>。唯一要注意的是<code>OC</code>的函数命名和<code>JS</code>函数命名规则问题。协议中定义的是<code>add: b:</code>，但是<code>JS</code>里面方法名字是<code>add(a,b)</code>。可以通过<code>JSExportAs</code>这个宏转换成<code>JS</code>的函数名字。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>Objective-C</code>的异常会在运行时被<code>Xcode</code>捕获，而在<code>JSContext</code>中执行的<code>JavaScript</code>如果出现异常，只会被<code>JSContext</code>捕获并存储在<code>exception</code>属性上，而不会向外抛出。时时刻刻检查<code>JSContext</code>对象的<code>exception</code>是否不为<code>nil</code>显然是不合适，更合理的方式是给<code>JSContext</code>对象设置<code>exceptionHandler</code>，它接受的是<code>^(JSContext *context, JSValue *exceptionValue)</code>形式的<code>Block</code>。其默认值就是将传入的<code>exceptionValue</code>赋给传入的<code>context的exception</code>属性：</p><pre><code class="objc">JSContext *context = [[JSContext alloc] init];context.exceptionHandler = ^(JSContext *con, JSValue *exception) {NSLog(@&quot;%@&quot;, exception);con.exception = exception;};[context evaluateScript:@&quot;fengzhen = 66&quot;];//输出://  ReferenceError: Can&#39;t find variable: fengzhen</code></pre><p>无论是把<code>Block</code>传给<code>JSContext</code>对象让其变成<code>avaScript</code>方法，还是把它赋给<code>exceptionHandler</code>属性，在<code>Block</code>内都不要直接使用其外部定义的<code>JSContext</code>对象或者JSValue，应该将其当做参数传入到<code>Block</code>中，或者通过<code>JSContext</code>的类方法<code>+ (JSContext *)currentContext;</code>来获得。否则会造成循环引用使得内存无法被正确释放。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><code>OC</code>使用的是<code>ARC</code>，<code>JS</code>使用的是垃圾回收机制，js的引用全都是强引用，垃圾回收机制会帮他们打破这种强引用，所以JS不存在循环引用的问题。一般情况下，<code>OC</code>和<code>JS</code>对象之间内存管理都无需我们去关心。不过还是有几个注意点需要我们去留意下。</p><h4 id="不要在block里面直接使用context，或者使用外部的JSValue对象。"><a href="#不要在block里面直接使用context，或者使用外部的JSValue对象。" class="headerlink" title="不要在block里面直接使用context，或者使用外部的JSValue对象。"></a>不要在<code>block</code>里面直接使用<code>context</code>，或者使用外部的<code>JSValue</code>对象。</h4><pre><code class="objc">JSContext *context = [[JSContext alloc] init];//设置异常处理self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) {//直接这么使用是错误的//context.exception = exception;[JSContext currentContext].exception = exception;NSLog(@&quot;exception:%@&quot;,exception);};</code></pre><h4 id="OC对象不要用属性直接保存JSValue对象，因为这样太容易造成循环引用。"><a href="#OC对象不要用属性直接保存JSValue对象，因为这样太容易造成循环引用。" class="headerlink" title="OC对象不要用属性直接保存JSValue对象，因为这样太容易造成循环引用。"></a><code>OC</code>对象不要用属性直接保存<code>JSValue</code>对象，因为这样太容易造成循环引用。</h4><p>下面的例子：</p><pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;#import &lt;JavaScriptCore/JavaScriptCore.h&gt;//首先写一个协议  遵守JSExport协议@protocol JSExportTest &lt;JSExport&gt;//宏转换下，将JS函数名称指定为Add；JSExportAs(add, - (NSInteger)add:(NSInteger)a b:(NSInteger)b);@property (nonatomic, strong) JSValue *value;@end//建一个对象实现这个协议@interface JSTest : NSObject&lt;JSExportTest&gt;@end</code></pre><pre><code class="objc">#import &quot;JSTest.h&quot;@implementation JSTest@synthesize value = _value;//实现协议方法-(void)setValue:(JSValue *)value{_value = value;}@end</code></pre><p><code>viewController里面</code></p><pre><code class="objc">JSContext *context = [[JSContext alloc]init];context.exceptionHandler = ^(JSContext *j, JSValue *v){NSLog(@&quot;%@&quot;,j.exception);};[context evaluateScript:@&quot;function callback(){return &#39;hello world&#39;};function setObj(obj){this.obj = obj;obj.value = callback}&quot;];[context[@&quot;setObj&quot;] callWithArguments:@[self.testObj]];</code></pre><p>调用<code>JS</code>方法，进行赋值，JS对象保留了传进来的obj，最后，JS将自己的回调callback赋值给了obj，方便obj下次回调给JS；由于JS那边保存了obj，而且obj这边也保留了JS的回调。这样就形成了循环引用。<br>为了打破这种强引用，apple有一个JSManagedValue 的类，官方的原话：</p><pre><code class="objc">The JSManagedValue&#39;s JavaScript value is reachable from JavaScriptThe owner of the managed reference is reachable in Objective-C. Manually adding or removing the managed reference in the JSVirtualMachine determines reachability.</code></pre><p>JSManagedValue 帮助我们保存JSValue，里面保存的JS对象必须在JS中存在，同时 JSManagedValue 的owner在OC中也存在.因此我们把代理的m文件修改如下：</p><pre><code class="objc">-(void)setValue:(JSValue *)value{//    由于是回掉的关系  obj保存了JS的回掉， js也保存了obj，这样就形成了循环引用//    JSManageValue帮助我们保存了JSValue，哪里保存的js对象在js中存在。 JSMangerValue的owner在OC中也存在。JSManagedValue *mavalue = [JSManagedValue managedValueWithValue:value];//建立弱引用关系[[[JSContext  currentContext] virtualMachine] addManagedReference:mavalue withOwner:self];_value = value;}</code></pre><h4 id="不要在不同的-JSVirtualMachine-之间进行传递JS对象。"><a href="#不要在不同的-JSVirtualMachine-之间进行传递JS对象。" class="headerlink" title="不要在不同的 JSVirtualMachine 之间进行传递JS对象。"></a>不要在不同的 JSVirtualMachine 之间进行传递JS对象。</h4><p>一个JSVirtualMachine可以运行多个context，由于都是在同一个堆内存和同一个垃圾回收下，所以相互之间传值是没问题的。但是如果在不同的 JSVirtualMachine传值，垃圾回收就不知道他们之间的关系了，可能会引起异常。</p><h4 id="JavaScriptCore线程是安全的。"><a href="#JavaScriptCore线程是安全的。" class="headerlink" title="JavaScriptCore线程是安全的。"></a>JavaScriptCore线程是安全的。</h4><p>每个context运行的时候通过lock关联的JSVirtualMachine。如果要进行并发操作，可以创建多个JSVirtualMachine实例进行操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  这是&lt;code&gt;JavaScriptCore&lt;/code&gt;的第二篇&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
